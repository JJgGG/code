可观测性 Observability
对线上应用进行观测、监控、预警...
● 健康状况【组件状态、存活状态】Health
● 运行指标【cpu、内存、垃圾回收、吞吐量、响应成功率...】Metrics
● 链路追踪
暴露指标
Properties
management:
  endpoints:
    enabled-by-default: true #暴露所有端点信息
    web:
      exposure:
        include: '*'  #以web方式暴露
###################################################
Endpoint
1. 常用端点
ID	描述
auditevents	暴露当前应用程序的审核事件信息。需要一个AuditEventRepository组件。
beans	显示应用程序中所有Spring Bean的完整列表。
caches	暴露可用的缓存。
conditions	显示自动配置的所有条件信息，包括匹配或不匹配的原因。
configprops	显示所有@ConfigurationProperties。
env	暴露Spring的属性ConfigurableEnvironment
flyway	显示已应用的所有Flyway数据库迁移。
需要一个或多个Flyway组件。
health	显示应用程序运行状况信息。
httptrace	显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个HttpTraceRepository组件。
info	显示应用程序信息。
integrationgraph	显示Spring integrationgraph 。需要依赖spring-integration-core。
loggers	显示和修改应用程序中日志的配置。
liquibase	显示已应用的所有Liquibase数据库迁移。需要一个或多个Liquibase组件。
metrics	显示当前应用程序的“指标”信息。
mappings	显示所有@RequestMapping路径列表。
scheduledtasks	显示应用程序中的计划任务。
sessions	允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。
shutdown	使应用程序正常关闭。默认禁用。
startup	显示由ApplicationStartup收集的启动步骤数据。需要使用SpringApplication进行配置BufferingApplicationStartup。
threaddump	执行线程转储。
heapdump	返回hprof堆转储文件。
jolokia	通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖jolokia-core。
logfile	返回日志文件的内容（如果已设置logging.file.name或logging.file.path属性）。支持使用HTTPRange标头来检索部分日志文件的内容。
prometheus	以Prometheus服务器可以抓取的格式公开指标。需要依赖micrometer-registry-prometheus。
#######################################################################################
定制端点
健康监控：返回存活、死亡
指标监控：次数、率
1. HealthEndpoint
Properties

management:
    health:
      enabled: true
      show-details: always #总是显示详细信息。可显示每个模块的状态信息

@Component
public class MyComHealthIndicator extends AbstractHealthIndicator {

    /**
     * 真实的检查方法
     * @param builder
     * @throws Exception
     */
    @Override
    protected void doHealthCheck(Health.Builder builder) throws Exception {
        //mongodb。  获取连接进行测试
        Map<String,Object> map = new HashMap<>();
        // 检查完成
        if(1 == 2){
//            builder.up(); //健康
            builder.status(Status.UP);
            map.put("count",1);
            map.put("ms",100);
        }else {
//            builder.down();
            builder.status(Status.OUT_OF_SERVICE);
            map.put("err","连接超时");
            map.put("ms",3000);
        }


        builder.withDetail("code",100)
                .withDetails(map);

    }
}
2. MetricsEndpoint

class MyService{
    Counter counter;
    public MyService(MeterRegistry meterRegistry){
         counter = meterRegistry.counter("myservice.method.running.counter");
    }

    public void hello() {
        counter.increment();
    }
}