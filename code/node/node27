2023年9月21号
###########################################
自动配置原理
1. 入门理解
应用关注的三大核心：场景、配置、组件
1. 导入starter
2. 依赖导入autoconfigure
3. 寻找类路径下 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件
4. 启动，加载所有 自动配置类 xxxAutoConfiguration
  a. 给容器中配置功能组件
  b. 组件参数绑定到 属性类中。xxxProperties
  c. 属性类和配置文件前缀项绑定
  d. @Contional派生的条件注解进行判断是否组件生效
5. 效果：
  a. 修改配置文件，修改底层参数
  b. 所有场景自动配置好直接使用
  c. 可以注入SpringBoot配置好的组件随时使用
##############################################
SPI机制
● Java中的SPI（Service Provider Interface）是一种软件设计模式，用于在应用程序中动态地发现和加载组件。
SPI的思想是，定义一个接口或抽象类，然后通过在classpath中定义实现该接口的类来实现对组件的动态发现和加载。
● SPI的主要目的是解决在应用程序中使用可插拔组件的问题。例如，一个应用程序可能需要使用不同的日志框架或数据库连接池，
但是这些组件的选择可能取决于运行时的条件。通过使用SPI，应用程序可以在运行时发现并加载适当的组件，而无需在代码中硬编码这些组件的实现类。
● 在Java中，SPI的实现方式是通过在META-INF/services目录下创建一个以服务接口全限定名为名字的文件，
文件中包含实现该服务接口的类的全限定名。当应用程序启动时，Java的SPI机制会自动扫描classpath中的这些文件，并根据文件中指定的类名来加载实现类。
● 通过使用SPI，应用程序可以实现更灵活、可扩展的架构，同时也可以避免硬编码依赖关系和增加代码的可维护性。
#############################################
功能开关
● 自动配置：全部都配置好，什么都不用管。   自动批量导入
  ○ 项目一启动，spi文件中指定的所有都加载。
● @EnableXxxx：手动控制哪些功能的开启； 手动导入。
  ○ 开启xxx功能
  ○ 都是利用 @Import 把此功能要用的组件导入进去
#######################################################
1. @SpringBootApplication
@SpringBootConfiguration
就是： @Configuration ，容器中的组件，配置类。spring ioc启动就会加载创建这个类对象

@EnableAutoConfiguration：开启自动配置
开启自动配置
  @AutoConfigurationPackage：扫描主程序包：加载自己的组件
  ● 利用 @Import(AutoConfigurationPackages.Registrar.class) 想要给容器中导入组件。
  ● 把主程序所在的包的所有组件导入进来。
  ● 为什么SpringBoot默认只扫描主程序所在的包及其子包

  @Import(AutoConfigurationImportSelector.class)：加载所有自动配置类：加载starter导入的组件
		List<String> configurations = ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader())
			.getCandidates();
扫描SPI文件：META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports

@ComponentScan
组件扫描：排除一些组件（哪些不要）
排除前面已经扫描进来的配置类、和自动配置类。
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
######################################################################
自定义starter
场景：抽取聊天机器人场景，它可以打招呼。
效果：任何项目导入此starter都具有打招呼功能，并且问候语中的人名需要可以在配置文件中修改
● 1. 创建自定义starter项目，引入spring-boot-starter基础依赖
● 2. 编写模块功能，引入模块所有需要的依赖。
● 3. 编写xxxAutoConfiguration自动配置类，帮其他项目导入这个模块需要的所有组件
● 4. 编写配置文件META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports指定启动需要加载的自动配置
● 5. 其他项目引入即可使用


 业务代码
自定义配置有提示。导入以下依赖重启项目，再写配置文件就有提示
@ConfigurationProperties(prefix = "robot")  //此属性类和配置文件指定前缀绑定
@Component
@Data
public class RobotProperties {

    private String name;
    private String age;
    private String email;
}


<!--        导入配置处理器，配置文件自定义的properties配置都会有提示-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>

2. 基本抽取
● 创建starter项目，把公共代码需要的所有依赖导入
● 把公共代码复制进来
● 自己写一个 RobotAutoConfiguration，给容器中导入这个场景需要的所有组件
  ○ 为什么这些组件默认不会扫描进去？
  ○ starter所在的包和 引入它的项目的主程序所在的包不是父子层级
● 别人引用这个starter，直接导入这个 RobotAutoConfiguration,就能把这个场景的组件导入进来
● 功能生效。
● 测试编写配置文件

3. 使用@EnableXxx机制
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
@Documented
@Import(RobotAutoConfiguration.class)
public @interface EnableRobot {


}
别人引入starter需要使用 @EnableRobot开启功能

4. 完全自动配置
● 依赖SpringBoot的SPI机制
● META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中编写好我们自动配置类的全类名即可
● 项目启动，自动加载我们的自动配置类


